#pragma once
#include <shape_msgs/msg/mesh.hpp>
#include <nuc_ros2/nuc.hpp>
#include <Eigen/Dense> 

namespace nuc_ros2
{

/**
 * @brief Converts a ROS2 Mesh message into flat vectors of triangle indices and vertex coordinates.
 * 
 * This function extracts triangle connectivity and vertex positions from a ROS Mesh message 
 * and flattens them into contiguous std::vectors. This format is often used for 
 * interoperability with low-level graphics libraries or specific computational algorithms.
 *
 * @param the_mesh Input ROS2 mesh message containing triangles and vertices.
 * @param facet_vertices Output vector that will be resized to contain facet vertex indices in a flat format.
 *                       For legacy triangle meshes this is [v0, v1, v2, v0, v1, v2, ...].
 * @param vertex_positions Output vector that will be resized to contain vertex coordinates.
 *                         The format is [x, y, z, x, y, z, ...] for each vertex.
 */
void convertMeshToVector(const shape_msgs::msg::Mesh& the_mesh, 
    std::vector<int>& facet_vertices, std::vector<double>& vertex_positions,
    unsigned int& coord_dim);

/**
 * @brief Computes a directed adjacency matrix for a polygonal mesh.
 *
 * This function iterates over each face of the mesh and populates a map
 `amd` where the key represents a directed edge (u -> v) and the value is the
index of the face that owns this edge.
*
* @param vertices_order A flat vector containing the vertex indices for all faces.
*                       The vertices of a face are listed consecutively.
* @param first_vertices_offset A vector where first_vertices_offset[i] gives the
*                              starting index of the i-th face's vertices in
*                              the `vertices_order` vector. The size of this
*                              vector is `num_faces + 1`.
* @param ver_num The total number of vertices in the mesh. This is needed to
*                calculate the unique key for each edge.
* @param amd The output unordered_map representing the sparse adjacency matrix.
*            The map key is `u + ver_num * v` for a directed edge from vertex u to v.
*            The map value is the index of the face.
*/
void compute_adjacency_matrix_directed(const std::vector<int>& vertices_order,
    const std::vector<int>& first_vertices_offset, 
    unsigned int ver_num,
    std::unordered_map<int, int>& amd);


/**
 * @brief Determines the list of indices of adjacent facets for each facet.
 *
 * For each facet, this function iterates through its edges. It queries the 
 * directed adjacency map (`amd`) to find if there is a neighboring facet 
 * sharing the same edge but in the opposite direction (reverse edge).
 *
 * @param all_facets Vector of Facet objects. The `adjacent_facets_index_` member
 *                   of each facet will be populated. If no neighbor is found 
 *                   for an edge (mesh boundary), -1 is inserted.
 * @param amd The directed adjacency map generated by `compute_adjacency_matrix_directed`.
 */
void determine_facet_adjacency(std::vector<Facet>& all_facets, const std::unordered_map<int, int>& amd, unsigned int ver_num);


/**
 * @brief Recursively assigns parent-child connections (spanning tree) to the mesh facets.
 *
 * This function performs a Depth-First Search (DFS) starting from a root facet.
 * It establishes a hierarchical structure by setting `parent_index_` and 
 * `parent_edge_index_` for each visited facet. The traversal preserves the 
 * cyclic order of adjacent edges but skips the edge leading back to the parent 
 * to prevent cycles.
 *
 * @param all_facets Vector of Facet objects. Their `parent_index_` and 
 *                   `parent_edge_index_` will be updated.
 * @param root_facet The index of the current facet to process as the root of the local subtree.
 * @param edge_index The index of the edge within `root_facet` that connects to its parent.
 *                   For the initial call, this value determines which edge is 
 *                   considered the "connection" to the parent.
 */
void assignFacetConnection(std::vector<Facet>& all_facets, int root_facet, int edge_index);

}